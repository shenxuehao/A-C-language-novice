#define _CRT_SECURE_NO_DEPRECATE
#include <stdio.h>
int main()
{
	int num = 0;
	int count = 0;
	scanf("%d", &num);
	//32bit
	int i = 0;
	for (i = 0; i < 32; i++)
	{
		num >> i;
	}
	return 0;
}


//#include <stdio.h>//求一个整数存储在内存中的二进制中1的个数
//int main()
//{
//	
//	int num = 0;
//	int count = 0;
//	scanf("%d", &num);
//	//统计num的补码中有几个1 
//	//得到二进制位的方法
//	while (num)
//	{
//		if (num % 2 == 1)
//		{
//			count++;
//		}
//		num = num / 2;//如果是3，模2就余011中的最后一个1，商1就相当于把最后一个1去掉了，就剩下01
//	}
//	printf("%d\n", count);
//	return 0;
//}//有缺陷，如果是-1就不行了



//#include <stdio.h>//交换两个数，不创建临时变量
//int main()//异或法
//{
//	int a = 3;
//	int b = 5;
//	a = a^b;
//	b = a^b;
//	a = a^b;
//	printf("a=%d,b=%d", a, b);
//	//a和b异或产生的密码，如果再次和原来的5异或，能翻译出来3；
//	//如果和3异或，能翻译出来5
//}
//





//int main()//加减法
//{
//	int a = 3;
//	int b = 5;
//	printf("请输入a的值:>");
//	scanf("a=%d", &a);
//	printf("请输入b的值:>");
//	scanf("b=%d", &b);
//	a = a + b;//有缺陷，相加可能会超出整型值的范围，溢出
//	b = a - b;
//	a = a - b;
//	printf("a=%d,b=%d", a, b);
//	return 0;
//}






//int main()
//{
//	int b = 0;
//	int a = 5;//5的二进制序列为0000000000000000000000000000101
//	b = a << 1;//左边丢弃，右边补0,相当于*2的效果
//	printf("%d\n", b);
//	return 0;
//}
//
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a&b;
//	//00000000000000000000000000000011
//	//00000000000000000000000000000101
//	//00000000000000000000000000000001
//	printf("%d\n", c);
//	int d = a | b;//按位或
//	printf("%d\n", d);
//	//00000000000000000000000000000011
//	//00000000000000000000000000000101
//	//00000000000000000000000000000111
//	int e = a ^ b;//按位异或
//	//00000000000000000000000000000011
//	//00000000000000000000000000000101
//	//00000000000000000000000000000110  
//	printf("%d\n", e);
//	return 0;
//}






//右移
//#include <stdio.h>
//int main()
//{
//	int b = 0;
//	int a = -16;//-8
//	int c = -1;
//	int d = 0;
//	b = a >> 1;//移动二进制位16=00000000000000000000000000010000（32个比特位）
//	//有两种位移方式，一种为算术位移:右边的丢弃，左边补上原符号位，正数补0，负数补1，编译器用的就是这个
//	//另一种为逻辑右移：右边丢弃，左边补0
//	//b = c >> 1;-1
//	//关于-1向右移一位还是-1，整数的二进制表示有三种形式：原码、补码、反码，存储到内存中的是补码，a在移动的过程中移的也是补码，
//	//-1的原码为10000000000000000000000000000001，反码为11111111111111111111111111111110，补码为反码+1，即11111111111111111111111111111111//
//	d = c >> 1;
//	printf("%d\n%d\n%d\n", a, b, d);
//	return 0;
//}
//
//

//#include <stdio.h>
//int main()
//{
//	int a = 0;
//	float b = 0;
//	double c = 0;
//	double d = 0;
//	a = 5 / 2;
//	b = 5 / 2;
//	//c = 5 / 2;//c=2.00000
//	c = 5 / 2.0;//c=2.00000
//	//d = 5 % 2.0;// 非法，右操作数包含“double”类型，左右操作数必须都是整数 
//	printf("a=%d\nb=%f\nc=%lf\nd=%lf\n", a,b,c,d);//a=2,b=2.00000
//	return 0;
//}